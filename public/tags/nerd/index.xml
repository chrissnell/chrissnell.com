<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nerd on Chris Snell</title>
    <link>https://chrissnell.com/tags/nerd/</link>
    <description>Recent content in Nerd on Chris Snell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 10 Aug 2014 00:00:00 -0800</lastBuildDate>
    <atom:link href="https://chrissnell.com/tags/nerd/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Debugging APRS clients with a virtual null-modem cable using socat and tnc-server</title>
      <link>https://chrissnell.com/post/debugging-aprs-clients/</link>
      <pubDate>Sun, 10 Aug 2014 00:00:00 -0800</pubDate>
      
      <guid>https://chrissnell.com/post/debugging-aprs-clients/</guid>
      <description>&lt;p&gt;While working on my &lt;a href=&#34;http://github.com/chrissnell/GoBalloon&#34;&gt;GoBalloon&lt;/a&gt; project, I found myself needing to connect two AX.25/KISS APRS clients together for debugging purposes. &amp;nbsp; If your computer has two hardware RS-232 serial ports, you can accomplish this by connecting a null modem cable between the two ports and connecting an APRS client to each port. &amp;nbsp; I discovered an easier way to do this today and you don&amp;rsquo;t even need a serial port at all. &amp;nbsp; The trick is to use the &lt;strong&gt;socat&lt;/strong&gt; utility. &amp;nbsp;socat is available in most Linux distros and there are a few Windows ports out there, as well.&lt;/p&gt;

&lt;p&gt;To create the virtual null modem cable, run socat like this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;% socat -d -d pty,raw,echo=0 pty,raw,echo=0

2014/08/10 19:08:28 socat[25083] N PTY is /dev/pts/3
2014/08/10 19:08:28 socat[25083] N PTY is /dev/pts/4
2014/08/10 19:08:28 socat[25083] N starting data transfer loop with FDs [3,3] and [5,5]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see above, socat will respond with two virtual serial ports (ptys). &amp;nbsp;In the example above, they are /dev/pts/3 and /dev/pts/4.&lt;/p&gt;

&lt;p&gt;Once you have those, simply fire up your APRS clients and connect each of them to one of those virtual ports. &amp;nbsp; Everything sent by one client will be copied to the other client and vice-versa.&lt;/p&gt;

&lt;p&gt;If you are debugging an APRS client that uses KISS-over-TCP, you can use my &lt;a href=&#34;http://github.com/chrissnell/tnc-server&#34;&gt;tnc-server&lt;/a&gt; utility to bridge the virtual serial port and the network. &amp;nbsp;Simply tell tnc-server to attach to one of those virtual ports and it will open a network listener that you can connect your KISS-over-TCP client&amp;nbsp;to:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;./tnc-server -port=/dev/pts/3 -listen=0.0.0.0:6700
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;nbsp;If you want to attach two KISS-over-TCP clients to each other, simply fire up a second instance of tnc-server that listens on a different port.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #272822&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt; ./tnc-server -port=/dev/pts/4 -listen=0.0.0.0:6701
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;From there, connect one APRS client to &amp;nbsp;&amp;lt;your_machines_IP&amp;gt; &amp;nbsp;port 6700 and the other client to port 6701.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Homebrew AVR Programmer</title>
      <link>https://chrissnell.com/post/homebrew-avr-programmer/</link>
      <pubDate>Sat, 01 Dec 2012 00:00:00 -0800</pubDate>
      
      <guid>https://chrissnell.com/post/homebrew-avr-programmer/</guid>
      <description>&lt;p&gt;I finally got around to building a little&amp;nbsp;&lt;a href=&#34;http://en.wikipedia.org/wiki/Atmel_AVR&#34;&gt;Atmel AVR&lt;/a&gt;&amp;nbsp;chip programmer using some perfboard and a ZIF socket. &amp;nbsp; Using&amp;nbsp;&lt;a href=&#34;http://www.google.com/url?sa=t&amp;amp;amp;rct=j&amp;amp;amp;q=&amp;amp;amp;esrc=s&amp;amp;amp;source=web&amp;amp;amp;cd=1&amp;amp;amp;ved=0CC8QFjAA&amp;amp;amp;url=http%3A%2F%2Fwww.obdev.at%2Fproducts%2Fcrosspack%2Findex.html&amp;amp;amp;ei=daq5UKbAGKK6yQG_24GoBA&amp;amp;amp;usg=AFQjCNGYKbcitvOX-SQpY9TlxHGJIQwjzg&#34;&gt;CrossPack&amp;rsquo;s&lt;/a&gt;&amp;nbsp;gcc cross-compiler, I can now compile for the AVR chips on my Mac and burn them directly to the chip without using a Linux or Windows VM.&lt;/p&gt;

&lt;p&gt;I designed the programmer so that it can handle ATtiny25/45/85/2313 and ATmega48/88/168/328 chips, all in the same ZIF socket. &amp;nbsp;Spiffy.&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;https://chrissnell.com/images/post/avr_top.jpg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://chrissnell.com/images/post/avr_bottom.jpg&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;My programmer connects to the Mac via a&amp;nbsp;&lt;a href=&#34;https://www.sparkfun.com/products/9825&#34;&gt;Pocket AVR Programmer&lt;/a&gt;&amp;nbsp;from Sparkfun.&lt;/p&gt;

&lt;p&gt;For what it&amp;rsquo;s worth, here is how I burn a compiled .hex image to an ATtiny2313 chip:&lt;/p&gt;

&lt;pre&gt;avrdude -p attiny2313 -c usbtiny -U flash:w:FILENAME_TO_BURN&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s an example how how I set the fuses on the chip:&lt;/p&gt;

&lt;pre&gt;avrdude -p attiny2313 -c usbtiny -U lfuse:w:0xe4:m -U hfuse:w:0xdf:m -U efuse:w:0xff:m&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>